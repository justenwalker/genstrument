# genstrument

genstrument is a Go Code Generator for instrumenting interfaces and functions.

It takes interface and function definitions with special doc comments and creates wrapper implementations
which add instrumentation.

For a full example, see the [Example Code](./example).

## Comment Directives

Comments are made on the associated Interface type or functions for which the wrapper is generated. 
These comments alter the generator behavior.

Valid scopes of these comments are:

- `interface`: interface type
- `package-function`:  a package top-level function
- `interface-function`: interface method


| comment                       | valid scope                          | description                                                 |
|-------------------------------|--------------------------------------|-------------------------------------------------------------|
| `// +genstrument:wrap`        | interface, package-function          | enables wrapper generation                                  |
| `// +genstrument:prefix`      | interface, package-function          | sets the prefix on the generated type                       |                 
| `// +genstrument:external`    | interface                            | target an external interface type                           |
| `// +genstrument:constructor` | interface                            | set the prefix on the constructor function                  |              
| `// +genstrument:op`          | interface-function, package-function | change the span. name                                       |              
| `// +genstrument:attr`        | interface-function, package-function | set attributes on the span from an argument or named return |

### `// +genstrument:wrap`

Enable generating the instrumentation wrapper for the interface or function.
Without this comment, the interface or package level function will not be wrapped.

### `// +genstrument:external <package>.<InterfaceTypeName>`

**Example**: `// +genstrument:external example.MyInterface`

This comment makes the wrapped interface implement an external
interface from another package. The package must be imported in the
source file. This ensures the constructor returns this external
interface type instead of the interface on which this comment is made.

This is useful for wrapping an interface in another package which you do not 
want to alter with these instrumentation comments.
Additional type checks will be generated to ensure this interface
matches the external interface referenced by this comment.

### `// +genstrument:constructor <ConstructorPrefix>`

**Example**: `// +genstrument:constructor Instrument`

This determines the prefix used for the Constructor function generated 
for this wrapper type. The name of the constructor function follows the format
`{{constructor}}{{InterfaceName}}` like `InstrumentMyInterface`.

### `// +genstrument:prefix <wrapperTypePrefix>`

**Examples**:

- `// +genstrument:prefix traced`
- `// +genstrument:prefix Observe`

This determines the prefix used for the generated wrapper interface or function.
The name of the wrapper function follows the format:

- `{{prefix}}{{FunctionName}}` like `ObserveMyFunction`
- `{{prefix}}{{InterfaceName}}` like `tracedMyInterface`

### `// +genstrument:op <name>`

**Example**: `// +genstrument:op myOperationName`

This overrides the name of the span generated by the instrumentation.

### `// +genstrument:attr <attribute-key> <argument-name> [SetterFunction]`

**Example**: `// +genstrument:attr error err AnyTypeSetter`

This annotation is made on a function to trigger adding attributes to the span based on the function arguments or return values.

The `SetterFunction` is a function which takes the argument assignable to the argument type, and a `genstrument.AttributeSetter`
which it uses to set the attribute on the span. As an example, the implementation of `StringAttributeSetter` is as follows:

```go
// StringAttributeSetter sets string attributes on the span
func StringAttributeSetter[S ~string](s S, attr genstrument.AttributeSetter) {
	attr.String(string(s))
}
```

When the `SetterFunction` is omitted, `genstrument` will attempt to find a suitable pre-defined
function that is compatible with the argument type. This only works for a limited set of primitive types:
`~int|~float|~string|~bool|error`, so it is better to define a setter if you can.

## Example

### Source

```go
// SimpleService
//
// +genstrument:wrap
type SimpleService interface {
	// +genstrument:op helloOp
	// +genstrument:attr message message
	// +genstrument:attr result result
	// +genstrument:attr err err
	SayHello(ctx context.Context, message string) (result string, err error)
}

// MyFunction
//
// +genstrument:wrap
// +genstrument:prefix Trace
// +genstrument:op helloOp
// +genstrument:attr message message
// +genstrument:attr result result
// +genstrument:attr err err
func SimpleFunction(message string) (result string, err error) {
	return message, nil
}
```

### Generated

```go
// InstrumentSimpleService adds APM traces around the wrapped example.SimpleService using the provided tracer.
func InstrumentSimpleService(tracer genstrument.Tracer, wrapped example.SimpleService) example.SimpleService {
    return &instrumentedSimpleService{
        tracer: tracer,
        wrapped: wrapped,
    }
}

type instrumentedSimpleService struct {
    wrapped example.SimpleService
    tracer genstrument.Tracer
}

func (w *instrumentedSimpleService) SayHello(ctx context.Context,message string) (result string,err error) {
    // Start Span
    var span genstrument.Span
    ctx, span = w.tracer.StartSpan(ctx,"helloOp")
    // Set Input Attributes
    genstrument.SetStringAttribute(message,span.Attribute("message"))

    // call Wrapped Function
    result,err =  w.wrapped.SayHello(ctx,message)
    // Finish Span with Error
    if err != nil {
        span.EndError(err)
        return
    }
    // Set Return Attributes
    genstrument.SetStringAttribute(result,span.Attribute("result"))
    genstrument.SetErrorAttribute(err,span.Attribute("err"))

    // Finish Span with Success
    span.EndSuccess(ctx)
    return
}

// TraceSimpleFunction traces the given fn using the provided tracer tr.
func TraceSimpleFunction(tr genstrument.Tracer) func(message string) (result string,err error)  {
    return func(message string) (result string,err error) {
        var span genstrument.Span
        ctx := context.Background()
        ctx, span = tr.StartSpan(ctx,"helloOp")
        // Set Input Attributes
        genstrument.SetStringAttribute(message,span.Attribute("message"))

        // call Wrapped Function
        result,err =  example.SimpleFunction(message)
        // Finish Span with Error
        if err != nil {
            span.EndError(err)
            return
        }
        // Set Return Attributes
        genstrument.SetStringAttribute(result,span.Attribute("result"))
        genstrument.SetErrorAttribute(err,span.Attribute("err"))

        // Finish Span with Success
        span.EndSuccess(ctx)
        return
    }
}
```
